<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TweetBuzz</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babel-standalone@6/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 font-sans">
    <div id="root" class="container mx-auto p-4"></div>
    <script type="text/babel">
        const WALLET_ADDRESS = "addr_test1qqsg5dt72efhxc96mly92ttvcxwzx2wjnxxpurcccrrn87szcqjeqcrn8u3xdmdrzuyax6r969d5zjm0uxnxacmmlwqs6j3ppt";
        const BLOCKFROST_API_KEY = "preview80iu63gdF0gDvHcl7EWsfen1vUKHpvpO"; // Your provided key
        const API_URL = "/api/tweetbuzz";

        const TweetBuzzApp = () => {
            const [keyword, setKeyword] = React.useState("Cardano");
            const [startDate, setStartDate] = React.useState("");
            const [endDate, setEndDate] = React.useState("");
            const [tweets, setTweets] = React.useState([]);
            const [transactions, setTransactions] = React.useState([]);
            const [loading, setLoading] = React.useState(false);
            const [error, setError] = React.useState("");
            const [walletConnected, setWalletConnected] = React.useState(false);
            const [yoroiApi, setYoroiApi] = React.useState(null);

            // Load CardanoWasm
            const loadCardanoWasm = async () => {
                try {
                    const module = await import('https://cdn.jsdelivr.net/npm/@emurgo/cardano-serialization-lib-browser@12.0.0/+esm');
                    console.log("CardanoWasm loaded:", !!module.TransactionBuilder);
                    return module;
                } catch (err) {
                    console.error("Failed to load CardanoWasm:", err);
                    throw new Error("Failed to load Cardano serialization library");
                }
            };

            // Connect to Yoroi wallet
            const connectWallet = async () => {
                setLoading(true);
                setError("");
                try {
                    if (!window.cardano || !window.cardano.yoroi) {
                        throw new Error("Yoroi wallet not detected. Please install Yoroi extension.");
                    }
                    const yoroi = await window.cardano.yoroi.enable();
                    setYoroiApi(yoroi);
                    setWalletConnected(true);
                    console.log("Wallet connected");
                } catch (err) {
                    setError(`Wallet connection error: ${err.message}`);
                    console.error("Wallet connection error:", err);
                } finally {
                    setLoading(false);
                }
            };

            // Disconnect wallet
            const disconnectWallet = () => {
                setYoroiApi(null);
                setWalletConnected(false);
                setError("Wallet disconnected. Reconnect to sign transactions.");
                console.log("Wallet disconnected");
            };

            // Fetch transactions from API
            const fetchTransactions = async () => {
                setLoading(true);
                setError("");
                try {
                    console.log("Fetching transactions from:", API_URL);
                    const response = await fetch(API_URL);
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API error: ${response.status} ${errorText}`);
                    }
                    const data = await response.json();
                    console.log("Transactions fetched:", data.transactions);
                    setTransactions(data.transactions || []);
                } catch (err) {
                    setError(`Fetch error: ${err.message}`);
                    console.error("Fetch error:", err);
                } finally {
                    setLoading(false);
                }
            };

            // Sign and submit transaction
            const signAndSubmit = async (txData) => {
                try {
                    if (!yoroiApi) {
                        throw new Error("Yoroi wallet not connected.");
                    }
                    const CardanoWasm = await loadCardanoWasm();
                    const txBuilder = CardanoWasm.TransactionBuilder.new();
                    txBuilder.add_output(
                        CardanoWasm.TransactionOutput.new(
                            CardanoWasm.Address.from_bech32(txData.address),
                            CardanoWasm.Value.new(CardanoWasm.BigNum.from_str(txData.amount.toString()))
                        )
                    );
                    const metadata = CardanoWasm.GeneralTransactionMetadata.new();
                    metadata.insert(
                        CardanoWasm.BigNum.from_str('674'),
                        CardanoWasm.encode_json_str_to_metadatum(JSON.stringify(txData.metadata), 0)
                    );
                    txBuilder.set_metadata(metadata);
                    txBuilder.set_change_address(CardanoWasm.Address.from_bech32(txData.address));
                    const unsignedTx = txBuilder.build();
                    console.log("Unsigned transaction built");
                    const signedTx = await yoroiApi.signTx(unsignedTx.to_hex());
                    const txId = signedTx.tx_hash();
                    await yoroiApi.submitTx(signedTx.to_hex());
                    console.log("Transaction submitted:", txId);
                    return txId;
                } catch (err) {
                    console.error("Signing error:", err);
                    throw new Error(`Signing error: ${err.message}`);
                }
            };

            // Query stored tweets
            const queryTweets = async () => {
                setLoading(true);
                setError("");
                try {
                    console.log("Querying transactions for address:", WALLET_ADDRESS);
                    const response = await fetch(`https://cardano-preview.blockfrost.io/api/v0/addresses/${WALLET_ADDRESS}/txs`, {
                        headers: { "project_id": BLOCKFROST_API_KEY }
                    });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Blockfrost error: ${response.status} ${errorText}`);
                    }
                    const txs = await response.json();
                    console.log("Transactions found:", txs.length);
                    const results = [];
                    for (const tx of txs.slice(0, 50)) {
                        const metadata = await fetch(`https://cardano-preview.blockfrost.io/api/v0/txs/${tx.tx_hash}/metadata`, {
                            headers: { "project_id": BLOCKFROST_API_KEY }
                        });
                        if (!metadata.ok) continue;
                        const metadataJson = await metadata.json();
                        metadataJson.forEach(m => {
                            if (m.label === "674" && m.json_metadata.tweet_data.keyword === keyword) {
                                results.push(m.json_metadata.tweet_data);
                            }
                        });
                    }
                    const filtered = results.filter(r => {
                        const tweetDate = new Date(r.timestamp);
                        return (!startDate || tweetDate >= new Date(startDate)) &&
                               (!endDate || tweetDate <= new Date(endDate));
                    });
                    console.log("Filtered tweets:", filtered.length);
                    setTweets(filtered);
                } catch (err) {
                    setError(`Query error: ${err.message}`);
                    console.error("Query error:", err);
                } finally {
                    setLoading(false);
                }
            };

            // Sign all transactions
            const handleSignAll = async () => {
                setLoading(true);
                setError("");
                try {
                    const txIds = [];
                    for (const txData of transactions) {
                        const txId = await signAndSubmit(txData);
                        txIds.push(txId);
                    }
                    setError(`Signed ${txIds.length} transactions: ${txIds.join(', ')}`);
                    await queryTweets();
                } catch (err) {
                    setError(`Error: ${err.message}`);
                    console.error("Sign all error:", err);
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="max-w-3xl mx-auto bg-white p-6 rounded-lg shadow-md">
                    <h1 className="text-3xl font-bold mb-4 text-center">TweetBuzz</h1>
                    <div className="mb-4 flex gap-2">
                        {walletConnected ? (
                            <button
                                onClick={disconnectWallet}
                                className="w-full bg-red-500 text-white p-2 rounded hover:bg-red-600"
                            >
                                Disconnect Wallet
                            </button>
                        ) : (
                            <button
                                onClick={connectWallet}
                                disabled={loading}
                                className="w-full bg-purple-500 text-white p-2 rounded hover:bg-purple-600 disabled:bg-gray-400"
                            >
                                {loading ? "Connecting..." : "Connect Wallet"}
                            </button>
                        )}
                    </div>
                    <div className="mb-4">
                        <button
                            onClick={fetchTransactions}
                            disabled={loading}
                            className="w-full bg-green-500 text-white p-2 rounded hover:bg-green-600 disabled:bg-gray-400 mb-2"
                        >
                            {loading ? "Loading..." : "Fetch Transactions"}
                        </button>
                        <button
                            onClick={handleSignAll}
                            disabled={loading || transactions.length === 0 || !walletConnected}
                            className="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600 disabled:bg-gray-400"
                        >
                            {loading ? "Signing..." : `Sign ${transactions.length} Transactions`}
                        </button>
                    </div>
                    <div className="mb-4">
                        <label className="block text-sm font-medium mb-1">Keyword</label>
                        <input
                            type="text"
                            value={keyword}
                            onChange={(e) => setKeyword(e.target.value)}
                            className="w-full p-2 border rounded"
                            placeholder="e.g., Cardano"
                        />
                    </div>
                    <div className="mb-4 flex gap-4">
                        <div className="flex-1">
                            <label className="block text-sm font-medium mb-1">Start Date</label>
                            <input
                                type="date"
                                value={startDate}
                                onChange={(e) => setStartDate(e.target.value)}
                                className="w-full p-2 border rounded"
                            />
                        </div>
                        <div className="flex-1">
                            <label className="block text-sm font-medium mb-1">End Date</label>
                            <input
                                type="date"
                                value={endDate}
                                onChange={(e) => setEndDate(e.target.value)}
                                className="w-full p-2 border rounded"
                            />
                        </div>
                    </div>
                    <button
                        onClick={queryTweets}
                        disabled={loading}
                        className="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600 disabled:bg-gray-400"
                    >
                        {loading ? "Loading..." : "Search Tweets"}
                    </button>
                    {error && <p className="mt-4 text-red-500">{error}</p>}
                    <div className="mt-6">
                        {tweets.length === 0 && !loading && <p>No tweets found.</p>}
                        {tweets.map(tweet => (
                            <div key={tweet.post_id} className="p-4 mb-4 bg-gray-50 rounded border">
                                <p><strong>ID:</strong> {tweet.post_id}</p>
                                <p><strong>Text:</strong> {tweet.text}</p>
                                <p><strong>Likes:</strong> {tweet.likes}</p>
                                <p><strong>Reposts:</strong> {tweet.reposts}</p>
                                <p><strong>Timestamp:</strong> {tweet.timestamp}</p>
                                <p><strong>Hash:</strong> {tweet.hash}</p>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        ReactDOM.render(<TweetBuzzApp />, document.getElementById('root'));
    </script>
</body>
</html>